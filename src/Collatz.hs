module Collatz
where

import qualified Data.Map as Map
import Data.Maybe

collatz :: Integer -> Map.Map Double Integer -- takes a number as input and then it returns a Map.
collatz n = help n [fromIntegral n]        -- every object's key is a number and every objects's value corresponds to the cardinality of the collatz sequence generated by the key as its input value.
  where
  help :: Integer -> [Double] -> Map.Map Double Integer
  help 1 saved = Map.fromList $ zip saved [1..]
  help n saved = let k = next n in help k (fromIntegral k : saved)

  next :: Integer -> Integer
  next n = if n `mod` 2 == 0 then n `div` 2 else 3 * n + 1

collatzSeqOfSteps :: Integer -> [(Double,Integer)]
collatzSeqOfSteps limit = generate [1 .. fromIntegral limit] (Map.singleton 1 1)
  where
  generate :: [Double] -> Map.Map Double Integer -> [(Double,Integer)]
  generate [] acc = Map.toList acc
  generate (x:xs) acc
    | Map.member x acc = generate xs acc
    | otherwise = generate xs $ Map.union acc $ (collatz . round) x

collatzGen :: Integer -> [(Double, Integer)] -- It is like collatz but it returns a list of pairs rather than a Map and it also enumerates the sequence backwards.
collatzGen n = help n [n]
  where
  help 1 saved = let start = (fromIntegral . length) saved
                 in zip [start, start - 1.0 ..] saved
  help n saved
    | n `mod` 2 == 0 = let next = n `div` 2 in help next (next:saved)
    | otherwise      = let next = 3 * n + 1 in help next (next:saved)

